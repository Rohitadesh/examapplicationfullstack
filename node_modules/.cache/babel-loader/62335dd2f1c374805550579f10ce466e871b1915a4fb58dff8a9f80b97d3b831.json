{"ast":null,"code":"var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\nvar cp = require('./cp');\nvar rm = require('./rm');\ncommon.register('mv', _mv, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force'\n  }\n});\n\n// Checks if cureent file was created recently\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n}\n\n//@\n//@ ### mv([options ,] source [, source ...], dest')\n//@ ### mv([options ,] source_array, dest')\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mv('-n', 'file', 'dir/');\n//@ mv('file1', 'file2', 'dir/');\n//@ mv(['file1', 'file2'], 'dir/'); // same as above\n//@ ```\n//@\n//@ Moves `source` file(s) to `dest`.\nfunction _mv(options, sources, dest) {\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else if (arguments.length > 3) {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  } else if (typeof sources === 'string') {\n    sources = [sources];\n  } else {\n    // TODO(nate): figure out if we actually need this line\n    common.error('invalid arguments');\n  }\n  var exists = fs.existsSync(dest);\n  var stats = exists && common.statFollowLinks(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!exists || !stats.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  }\n\n  // Dest is an existing file, but no -f given\n  if (exists && stats.isFile() && options.no_force) {\n    common.error('dest file already exists: ' + dest);\n  }\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: ' + src, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    // If here, src exists\n\n    // When copying to '/path/dir':\n    //    thisDest = '/path/dir/file1'\n    var thisDest = dest;\n    if (fs.existsSync(dest) && common.statFollowLinks(dest).isDirectory()) {\n      thisDest = path.normalize(dest + '/' + path.basename(src));\n    }\n    var thisDestExists = fs.existsSync(thisDest);\n    if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n      // cannot overwrite file created recently in current execution, but we want to continue copying other files\n      if (!options.no_force) {\n        common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", {\n          continue: true\n        });\n      }\n      return;\n    }\n    if (fs.existsSync(thisDest) && options.no_force) {\n      common.error('dest file already exists: ' + thisDest, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    if (path.resolve(src) === path.dirname(path.resolve(thisDest))) {\n      common.error('cannot move to self: ' + src, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    try {\n      fs.renameSync(src, thisDest);\n    } catch (e) {\n      /* istanbul ignore next */\n      if (e.code === 'EXDEV') {\n        // If we're trying to `mv` to an external partition, we'll actually need\n        // to perform a copy and then clean up the original file. If either the\n        // copy or the rm fails with an exception, we should allow this\n        // exception to pass up to the top level.\n        cp('-r', src, thisDest);\n        rm('-rf', src);\n      }\n    }\n  }); // forEach(src)\n  return '';\n} // mv\nmodule.exports = _mv;","map":{"version":3,"names":["fs","require","path","common","cp","rm","register","_mv","cmdOptions","checkRecentCreated","sources","index","lookedSource","slice","some","src","basename","options","dest","arguments","length","error","call","exists","existsSync","stats","statFollowLinks","isDirectory","isFile","no_force","forEach","srcIndex","continue","thisDest","normalize","thisDestExists","resolve","dirname","renameSync","e","code","module","exports"],"sources":["/home/lenovo/node_modules/shelljs/src/mv.js"],"sourcesContent":["var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\nvar cp = require('./cp');\nvar rm = require('./rm');\n\ncommon.register('mv', _mv, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n  },\n});\n\n// Checks if cureent file was created recently\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n}\n\n//@\n//@ ### mv([options ,] source [, source ...], dest')\n//@ ### mv([options ,] source_array, dest')\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mv('-n', 'file', 'dir/');\n//@ mv('file1', 'file2', 'dir/');\n//@ mv(['file1', 'file2'], 'dir/'); // same as above\n//@ ```\n//@\n//@ Moves `source` file(s) to `dest`.\nfunction _mv(options, sources, dest) {\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else if (arguments.length > 3) {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  } else if (typeof sources === 'string') {\n    sources = [sources];\n  } else {\n    // TODO(nate): figure out if we actually need this line\n    common.error('invalid arguments');\n  }\n\n  var exists = fs.existsSync(dest);\n  var stats = exists && common.statFollowLinks(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!exists || !stats.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  }\n\n  // Dest is an existing file, but no -f given\n  if (exists && stats.isFile() && options.no_force) {\n    common.error('dest file already exists: ' + dest);\n  }\n\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: ' + src, { continue: true });\n      return; // skip file\n    }\n\n    // If here, src exists\n\n    // When copying to '/path/dir':\n    //    thisDest = '/path/dir/file1'\n    var thisDest = dest;\n    if (fs.existsSync(dest) && common.statFollowLinks(dest).isDirectory()) {\n      thisDest = path.normalize(dest + '/' + path.basename(src));\n    }\n\n    var thisDestExists = fs.existsSync(thisDest);\n\n    if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n      // cannot overwrite file created recently in current execution, but we want to continue copying other files\n      if (!options.no_force) {\n        common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", { continue: true });\n      }\n      return;\n    }\n\n    if (fs.existsSync(thisDest) && options.no_force) {\n      common.error('dest file already exists: ' + thisDest, { continue: true });\n      return; // skip file\n    }\n\n    if (path.resolve(src) === path.dirname(path.resolve(thisDest))) {\n      common.error('cannot move to self: ' + src, { continue: true });\n      return; // skip file\n    }\n\n    try {\n      fs.renameSync(src, thisDest);\n    } catch (e) {\n      /* istanbul ignore next */\n      if (e.code === 'EXDEV') {\n        // If we're trying to `mv` to an external partition, we'll actually need\n        // to perform a copy and then clean up the original file. If either the\n        // copy or the rm fails with an exception, we should allow this\n        // exception to pass up to the top level.\n        cp('-r', src, thisDest);\n        rm('-rf', src);\n      }\n    }\n  }); // forEach(src)\n  return '';\n} // mv\nmodule.exports = _mv;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}