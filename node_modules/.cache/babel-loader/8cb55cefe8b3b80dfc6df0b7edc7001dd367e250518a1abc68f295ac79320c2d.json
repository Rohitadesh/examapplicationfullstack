{"ast":null,"code":"var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\ncommon.register('cp', _cp, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n    'u': 'update',\n    'R': 'recursive',\n    'r': 'recursive',\n    'L': 'followsymlink',\n    'P': 'noFollowsymlink'\n  },\n  wrapOutput: false\n});\n\n// Buffered file copy, synchronous\n// (Using readFileSync() + writeFileSync() could easily cause a memory overflow\n//  with large files)\nfunction copyFileSync(srcFile, destFile, options) {\n  if (!fs.existsSync(srcFile)) {\n    common.error('copyFileSync: no such file or directory: ' + srcFile);\n  }\n  var isWindows = process.platform === 'win32';\n\n  // Check the mtimes of the files if the '-u' flag is provided\n  try {\n    if (options.update && common.statFollowLinks(srcFile).mtime < fs.statSync(destFile).mtime) {\n      return;\n    }\n  } catch (e) {\n    // If we're here, destFile probably doesn't exist, so just do a normal copy\n  }\n  if (common.statNoFollowLinks(srcFile).isSymbolicLink() && !options.followsymlink) {\n    try {\n      common.statNoFollowLinks(destFile);\n      common.unlinkSync(destFile); // re-link it\n    } catch (e) {\n      // it doesn't exist, so no work needs to be done\n    }\n    var symlinkFull = fs.readlinkSync(srcFile);\n    fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n  } else {\n    var buf = common.buffer();\n    var bufLength = buf.length;\n    var bytesRead = bufLength;\n    var pos = 0;\n    var fdr = null;\n    var fdw = null;\n    try {\n      fdr = fs.openSync(srcFile, 'r');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not read src file (' + srcFile + ')');\n    }\n    try {\n      fdw = fs.openSync(destFile, 'w');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not write to dest file (code=' + e.code + '):' + destFile);\n    }\n    while (bytesRead === bufLength) {\n      bytesRead = fs.readSync(fdr, buf, 0, bufLength, pos);\n      fs.writeSync(fdw, buf, 0, bytesRead);\n      pos += bytesRead;\n    }\n    fs.closeSync(fdr);\n    fs.closeSync(fdw);\n    fs.chmodSync(destFile, common.statFollowLinks(srcFile).mode);\n  }\n}\n\n// Recursively copies 'sourceDir' into 'destDir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction cpdirSyncRecursive(sourceDir, destDir, currentDepth, opts) {\n  if (!opts) opts = {};\n\n  // Ensure there is not a run away recursive copy\n  if (currentDepth >= common.config.maxdepth) return;\n  currentDepth++;\n  var isWindows = process.platform === 'win32';\n\n  // Create the directory where all our junk is moving to; read the mode of the\n  // source directory and mirror it\n  try {\n    fs.mkdirSync(destDir);\n  } catch (e) {\n    // if the directory already exists, that's okay\n    if (e.code !== 'EEXIST') throw e;\n  }\n  var files = fs.readdirSync(sourceDir);\n  for (var i = 0; i < files.length; i++) {\n    var srcFile = sourceDir + '/' + files[i];\n    var destFile = destDir + '/' + files[i];\n    var srcFileStat = common.statNoFollowLinks(srcFile);\n    var symlinkFull;\n    if (opts.followsymlink) {\n      if (cpcheckcycle(sourceDir, srcFile)) {\n        // Cycle link found.\n        console.error('Cycle link found.');\n        symlinkFull = fs.readlinkSync(srcFile);\n        fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n        continue;\n      }\n    }\n    if (srcFileStat.isDirectory()) {\n      /* recursion this thing right on back. */\n      cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n    } else if (srcFileStat.isSymbolicLink() && !opts.followsymlink) {\n      symlinkFull = fs.readlinkSync(srcFile);\n      try {\n        common.statNoFollowLinks(destFile);\n        common.unlinkSync(destFile); // re-link it\n      } catch (e) {\n        // it doesn't exist, so no work needs to be done\n      }\n      fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n    } else if (srcFileStat.isSymbolicLink() && opts.followsymlink) {\n      srcFileStat = common.statFollowLinks(srcFile);\n      if (srcFileStat.isDirectory()) {\n        cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    } else {\n      /* At this point, we've hit a file actually worth copying... so copy it on over. */\n      if (fs.existsSync(destFile) && opts.no_force) {\n        common.log('skipping existing file: ' + files[i]);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    }\n  } // for files\n\n  // finally change the mode for the newly created directory (otherwise, we\n  // couldn't add files to a read-only directory).\n  var checkDir = common.statFollowLinks(sourceDir);\n  fs.chmodSync(destDir, checkDir.mode);\n} // cpdirSyncRecursive\n\n// Checks if cureent file was created recently\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n}\nfunction cpcheckcycle(sourceDir, srcFile) {\n  var srcFileStat = common.statNoFollowLinks(srcFile);\n  if (srcFileStat.isSymbolicLink()) {\n    // Do cycle check. For example:\n    //   $ mkdir -p 1/2/3/4\n    //   $ cd  1/2/3/4\n    //   $ ln -s ../../3 link\n    //   $ cd ../../../..\n    //   $ cp -RL 1 copy\n    var cyclecheck = common.statFollowLinks(srcFile);\n    if (cyclecheck.isDirectory()) {\n      var sourcerealpath = fs.realpathSync(sourceDir);\n      var symlinkrealpath = fs.realpathSync(srcFile);\n      var re = new RegExp(symlinkrealpath);\n      if (re.test(sourcerealpath)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n//@\n//@ ### cp([options,] source [, source ...], dest)\n//@ ### cp([options,] source_array, dest)\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@ + `-u`: only copy if `source` is newer than `dest`\n//@ + `-r`, `-R`: recursive\n//@ + `-L`: follow symlinks\n//@ + `-P`: don't follow symlinks\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cp('file1', 'dir1');\n//@ cp('-R', 'path/to/dir/', '~/newCopy/');\n//@ cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp');\n//@ cp('-Rf', ['/tmp/*', '/usr/local/*'], '/home/tmp'); // same as above\n//@ ```\n//@\n//@ Copies files.\nfunction _cp(options, sources, dest) {\n  // If we're missing -R, it actually implies -L (unless -P is explicit)\n  if (options.followsymlink) {\n    options.noFollowsymlink = false;\n  }\n  if (!options.recursive && !options.noFollowsymlink) {\n    options.followsymlink = true;\n  }\n\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  }\n  var destExists = fs.existsSync(dest);\n  var destStat = destExists && common.statFollowLinks(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!destExists || !destStat.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  }\n\n  // Dest is an existing file, but -n is given\n  if (destExists && destStat.isFile() && options.no_force) {\n    return new common.ShellString('', '', 0);\n  }\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      if (src === '') src = \"''\"; // if src was empty string, display empty string\n      common.error('no such file or directory: ' + src, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    var srcStat = common.statFollowLinks(src);\n    if (!options.noFollowsymlink && srcStat.isDirectory()) {\n      if (!options.recursive) {\n        // Non-Recursive\n        common.error(\"omitting directory '\" + src + \"'\", {\n          continue: true\n        });\n      } else {\n        // Recursive\n        // 'cp /a/source dest' should create 'source' in 'dest'\n        var newDest = destStat && destStat.isDirectory() ? path.join(dest, path.basename(src)) : dest;\n        try {\n          common.statFollowLinks(path.dirname(dest));\n          cpdirSyncRecursive(src, newDest, 0, {\n            no_force: options.no_force,\n            followsymlink: options.followsymlink\n          });\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error(\"cannot create directory '\" + dest + \"': No such file or directory\");\n        }\n      }\n    } else {\n      // If here, src is a file\n\n      // When copying to '/path/dir':\n      //    thisDest = '/path/dir/file1'\n      var thisDest = dest;\n      if (destStat && destStat.isDirectory()) {\n        thisDest = path.normalize(dest + '/' + path.basename(src));\n      }\n      var thisDestExists = fs.existsSync(thisDest);\n      if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n        // cannot overwrite file created recently in current execution, but we want to continue copying other files\n        if (!options.no_force) {\n          common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", {\n            continue: true\n          });\n        }\n        return;\n      }\n      if (thisDestExists && options.no_force) {\n        return; // skip file\n      }\n\n      if (path.relative(src, thisDest) === '') {\n        // a file cannot be copied to itself, but we want to continue copying other files\n        common.error(\"'\" + thisDest + \"' and '\" + src + \"' are the same file\", {\n          continue: true\n        });\n        return;\n      }\n      copyFileSync(src, thisDest, options);\n    }\n  }); // forEach(src)\n\n  return new common.ShellString('', common.state.error, common.state.errorCode);\n}\nmodule.exports = _cp;","map":{"version":3,"names":["fs","require","path","common","register","_cp","cmdOptions","wrapOutput","copyFileSync","srcFile","destFile","options","existsSync","error","isWindows","process","platform","update","statFollowLinks","mtime","statSync","e","statNoFollowLinks","isSymbolicLink","followsymlink","unlinkSync","symlinkFull","readlinkSync","symlinkSync","buf","buffer","bufLength","length","bytesRead","pos","fdr","fdw","openSync","code","readSync","writeSync","closeSync","chmodSync","mode","cpdirSyncRecursive","sourceDir","destDir","currentDepth","opts","config","maxdepth","mkdirSync","files","readdirSync","i","srcFileStat","cpcheckcycle","console","isDirectory","no_force","log","checkDir","checkRecentCreated","sources","index","lookedSource","slice","some","src","basename","cyclecheck","sourcerealpath","realpathSync","symlinkrealpath","re","RegExp","test","dest","noFollowsymlink","recursive","arguments","call","destExists","destStat","isFile","ShellString","forEach","srcIndex","continue","srcStat","newDest","join","dirname","thisDest","normalize","thisDestExists","relative","state","errorCode","module","exports"],"sources":["/home/lenovo/node_modules/shelljs/src/cp.js"],"sourcesContent":["var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\n\ncommon.register('cp', _cp, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n    'u': 'update',\n    'R': 'recursive',\n    'r': 'recursive',\n    'L': 'followsymlink',\n    'P': 'noFollowsymlink',\n  },\n  wrapOutput: false,\n});\n\n// Buffered file copy, synchronous\n// (Using readFileSync() + writeFileSync() could easily cause a memory overflow\n//  with large files)\nfunction copyFileSync(srcFile, destFile, options) {\n  if (!fs.existsSync(srcFile)) {\n    common.error('copyFileSync: no such file or directory: ' + srcFile);\n  }\n\n  var isWindows = process.platform === 'win32';\n\n  // Check the mtimes of the files if the '-u' flag is provided\n  try {\n    if (options.update && common.statFollowLinks(srcFile).mtime < fs.statSync(destFile).mtime) {\n      return;\n    }\n  } catch (e) {\n    // If we're here, destFile probably doesn't exist, so just do a normal copy\n  }\n\n  if (common.statNoFollowLinks(srcFile).isSymbolicLink() && !options.followsymlink) {\n    try {\n      common.statNoFollowLinks(destFile);\n      common.unlinkSync(destFile); // re-link it\n    } catch (e) {\n      // it doesn't exist, so no work needs to be done\n    }\n\n    var symlinkFull = fs.readlinkSync(srcFile);\n    fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n  } else {\n    var buf = common.buffer();\n    var bufLength = buf.length;\n    var bytesRead = bufLength;\n    var pos = 0;\n    var fdr = null;\n    var fdw = null;\n\n    try {\n      fdr = fs.openSync(srcFile, 'r');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not read src file (' + srcFile + ')');\n    }\n\n    try {\n      fdw = fs.openSync(destFile, 'w');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not write to dest file (code=' + e.code + '):' + destFile);\n    }\n\n    while (bytesRead === bufLength) {\n      bytesRead = fs.readSync(fdr, buf, 0, bufLength, pos);\n      fs.writeSync(fdw, buf, 0, bytesRead);\n      pos += bytesRead;\n    }\n\n    fs.closeSync(fdr);\n    fs.closeSync(fdw);\n\n    fs.chmodSync(destFile, common.statFollowLinks(srcFile).mode);\n  }\n}\n\n// Recursively copies 'sourceDir' into 'destDir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction cpdirSyncRecursive(sourceDir, destDir, currentDepth, opts) {\n  if (!opts) opts = {};\n\n  // Ensure there is not a run away recursive copy\n  if (currentDepth >= common.config.maxdepth) return;\n  currentDepth++;\n\n  var isWindows = process.platform === 'win32';\n\n  // Create the directory where all our junk is moving to; read the mode of the\n  // source directory and mirror it\n  try {\n    fs.mkdirSync(destDir);\n  } catch (e) {\n    // if the directory already exists, that's okay\n    if (e.code !== 'EEXIST') throw e;\n  }\n\n  var files = fs.readdirSync(sourceDir);\n\n  for (var i = 0; i < files.length; i++) {\n    var srcFile = sourceDir + '/' + files[i];\n    var destFile = destDir + '/' + files[i];\n    var srcFileStat = common.statNoFollowLinks(srcFile);\n\n    var symlinkFull;\n    if (opts.followsymlink) {\n      if (cpcheckcycle(sourceDir, srcFile)) {\n        // Cycle link found.\n        console.error('Cycle link found.');\n        symlinkFull = fs.readlinkSync(srcFile);\n        fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n        continue;\n      }\n    }\n    if (srcFileStat.isDirectory()) {\n      /* recursion this thing right on back. */\n      cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n    } else if (srcFileStat.isSymbolicLink() && !opts.followsymlink) {\n      symlinkFull = fs.readlinkSync(srcFile);\n      try {\n        common.statNoFollowLinks(destFile);\n        common.unlinkSync(destFile); // re-link it\n      } catch (e) {\n        // it doesn't exist, so no work needs to be done\n      }\n      fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n    } else if (srcFileStat.isSymbolicLink() && opts.followsymlink) {\n      srcFileStat = common.statFollowLinks(srcFile);\n      if (srcFileStat.isDirectory()) {\n        cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    } else {\n      /* At this point, we've hit a file actually worth copying... so copy it on over. */\n      if (fs.existsSync(destFile) && opts.no_force) {\n        common.log('skipping existing file: ' + files[i]);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    }\n  } // for files\n\n  // finally change the mode for the newly created directory (otherwise, we\n  // couldn't add files to a read-only directory).\n  var checkDir = common.statFollowLinks(sourceDir);\n  fs.chmodSync(destDir, checkDir.mode);\n} // cpdirSyncRecursive\n\n// Checks if cureent file was created recently\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n}\n\nfunction cpcheckcycle(sourceDir, srcFile) {\n  var srcFileStat = common.statNoFollowLinks(srcFile);\n  if (srcFileStat.isSymbolicLink()) {\n    // Do cycle check. For example:\n    //   $ mkdir -p 1/2/3/4\n    //   $ cd  1/2/3/4\n    //   $ ln -s ../../3 link\n    //   $ cd ../../../..\n    //   $ cp -RL 1 copy\n    var cyclecheck = common.statFollowLinks(srcFile);\n    if (cyclecheck.isDirectory()) {\n      var sourcerealpath = fs.realpathSync(sourceDir);\n      var symlinkrealpath = fs.realpathSync(srcFile);\n      var re = new RegExp(symlinkrealpath);\n      if (re.test(sourcerealpath)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n//@\n//@ ### cp([options,] source [, source ...], dest)\n//@ ### cp([options,] source_array, dest)\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@ + `-u`: only copy if `source` is newer than `dest`\n//@ + `-r`, `-R`: recursive\n//@ + `-L`: follow symlinks\n//@ + `-P`: don't follow symlinks\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cp('file1', 'dir1');\n//@ cp('-R', 'path/to/dir/', '~/newCopy/');\n//@ cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp');\n//@ cp('-Rf', ['/tmp/*', '/usr/local/*'], '/home/tmp'); // same as above\n//@ ```\n//@\n//@ Copies files.\nfunction _cp(options, sources, dest) {\n  // If we're missing -R, it actually implies -L (unless -P is explicit)\n  if (options.followsymlink) {\n    options.noFollowsymlink = false;\n  }\n  if (!options.recursive && !options.noFollowsymlink) {\n    options.followsymlink = true;\n  }\n\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  }\n\n  var destExists = fs.existsSync(dest);\n  var destStat = destExists && common.statFollowLinks(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!destExists || !destStat.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  }\n\n  // Dest is an existing file, but -n is given\n  if (destExists && destStat.isFile() && options.no_force) {\n    return new common.ShellString('', '', 0);\n  }\n\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      if (src === '') src = \"''\"; // if src was empty string, display empty string\n      common.error('no such file or directory: ' + src, { continue: true });\n      return; // skip file\n    }\n    var srcStat = common.statFollowLinks(src);\n    if (!options.noFollowsymlink && srcStat.isDirectory()) {\n      if (!options.recursive) {\n        // Non-Recursive\n        common.error(\"omitting directory '\" + src + \"'\", { continue: true });\n      } else {\n        // Recursive\n        // 'cp /a/source dest' should create 'source' in 'dest'\n        var newDest = (destStat && destStat.isDirectory()) ?\n            path.join(dest, path.basename(src)) :\n            dest;\n\n        try {\n          common.statFollowLinks(path.dirname(dest));\n          cpdirSyncRecursive(src, newDest, 0, { no_force: options.no_force, followsymlink: options.followsymlink });\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error(\"cannot create directory '\" + dest + \"': No such file or directory\");\n        }\n      }\n    } else {\n      // If here, src is a file\n\n      // When copying to '/path/dir':\n      //    thisDest = '/path/dir/file1'\n      var thisDest = dest;\n      if (destStat && destStat.isDirectory()) {\n        thisDest = path.normalize(dest + '/' + path.basename(src));\n      }\n\n      var thisDestExists = fs.existsSync(thisDest);\n      if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n        // cannot overwrite file created recently in current execution, but we want to continue copying other files\n        if (!options.no_force) {\n          common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", { continue: true });\n        }\n        return;\n      }\n\n      if (thisDestExists && options.no_force) {\n        return; // skip file\n      }\n\n      if (path.relative(src, thisDest) === '') {\n        // a file cannot be copied to itself, but we want to continue copying other files\n        common.error(\"'\" + thisDest + \"' and '\" + src + \"' are the same file\", { continue: true });\n        return;\n      }\n\n      copyFileSync(src, thisDest, options);\n    }\n  }); // forEach(src)\n\n  return new common.ShellString('', common.state.error, common.state.errorCode);\n}\nmodule.exports = _cp;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}